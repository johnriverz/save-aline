{
  "team_id": "aline123",
  "items": [
    {
      "title": "Never Written Code But Passed Google System Design",
      "content": "Before you read this post, I (Aline Lerner, founder of interviewing.io) wanted to introduce it properly. It’s about something that’s a little bit nuts: a non-engineer passed a Google system design interview! What??! Surely something is misrepresented here, and surely something is overblown.\n\nHere are the facts and some key context:\nAt the bottom of this post, you can watch the full interview and judge for yourself.\n\nMy name is Kevin. I am not and have never been a software engineer. I have never written or tested a single line of code, and I have never even worked as a PM. My tech career started in (don’t hate me!) recruiting. Then moved into career coaching and salary negotiation before I got where I am now: creating content for engineers.\n\nWith a fraction of the domain knowledge most engineers have, I passed a Google system design interview. I passed because I learned a LOT about system design interviews before taking this interview. I also learned a few tricks along the way. If these tricks helped me pass, then imagine what you’ll be able to do with them.\n\nAt interviewing.io, part of my job is talking to candidates about the interview process. Many complain about system design interviews. They don’t know how to approach them or how to handle the ambiguity. Here’s what one of our users had to say:\n\n> System design interviews are very intimidating. The de facto assumption is that if you have worked for 5+ years, you should have excellent scalable systems experience and if you fail to show that at interviews, you're penalized either by not getting the offer or by getting down leveled significantly. The analogy I can think of is like asking an elephant to fly when the job description is to lift and move heavy things.\n\nAt the time, the most popular system design resources were eerily similar. None of them had good solutions for approaching, handling ambiguity in, or demystifying system design interviews. So, we decided to try to make the best system design guide in the world, and I got to lead the project.\n\nFirst, I talked to some of our highest-rated system design interviewers. Then, we started work on the guide. My role was to facilitate, listen, project manage, write, edit, and repeat.\n\nAfter months of work, we published A Senior Engineer’s Guide to the System Design Interview on March 2nd, 2023. It did well on Hacker News. If you Google “system design interview”, it’s the #1 result (as of when this post was published).\n\nAfter the guide was released, I met again with some of the contributors. Out of nowhere, one said, “I bet you could pass a system design interview.” The other two agreed. I accepted the challenge and decided I wouldn’t study; I’d just use what I learned from making the guide.\n\nI scheduled a mock system design interview with an interviewer from Google on interviewing.io for a Friday morning. My interviewer wouldn’t know who I was and would only know my years of experience (I said I had 4). The only other thing my interviewer would know about me was that I presumably was about to interview at Google and needed help preparing.\n\n### How to book Google system design interviews on interviewing.io\n\nI’ll walk you through a few clips from the interview that cover three key aspects of my experience: an unconventional idea, something I failed spectacularly at, and a moment I’m proud of.\n\nLast year, I went to Harvard Law School’s Advanced Negotiation Workshop. They spend a lot of time (33% of the whole workshop!) drilling into the specifics of how negotiations are often won or lost in the first and last 3 minutes. I approached the first 180 seconds of this system design interview with that in mind, and I knew I had to quickly score some social proof with the interviewer.\n\nThe unwritten codes of FAANG interviews taught me one unobvious way to score social proof. Win the competition about who cares less. I’m naturally enthusiastic so I had to trick myself. To find that devil-may-care attitude, I’d repeat a lyric from Green Day in my head: “I don’t care that you don’t care.”\n\nSimply put, I forgot you could cache data on a user’s device. More importantly, they grilled me about caching and I took it personally. I lost sight of the interview. Caught in a story of them as an adversary, I stopped listening. I ignored their follow-up questions and, ironically, their hints.\n\nAs Marcellus Wallace said in Pulp Fiction, \"Pride only hurts.\" I didn’t know the answers to their caching questions, and I was too proud to say “I don’t know.” Had I done that, they would’ve shifted gears. But I didn’t, so they assumed I actually did know, then the grilling continued. If I could go back in time, I’d do what our system design guide says to do when you’re not certain, but you have an idea.\n\nTell the interviewer:\n> \"I don't know, I'm definitely going to look that up right after this interview, but if I had to give my best guess I'd say... [x] and here is why [explanation/thought process].\"\n\nBreaking Google’s record for the number of times “Harry Styles” is repeated in one interview! Just kidding. My actual proud moment was staying calm when the interviewer said something scary. A candidate who gets scared, looks like an outsider. To look like an insider, stay calm.\n\nA common system design question is ‘Design Gmail.’ There are so many different dimensions, no one can design Gmail during an interview. That can’t happen. Whenever people ask you to ‘Design Gmail,’ that's to scare you.\n\n> Former Staff Engineer at Google\n\nThe topic of scale came up. And the interviewer said this system should be able to support 800 million active users. That quote from that staff engineer popped into my head, so I–while feigning the most casual tone possible–responded with a neutral “okay.” The word choice and delivery suggest “this is another day at the office for me” which implies “I’m not scared of this.” In my head, what I told myself was “I don’t care that you don’t care.”\n\nAt 41:00, you can hear him give me a “Weak/Lean Hire” for L4.\n\nWithout a firm foundation, tricks lose their magic. You can have all the tricks in the world, but if you don’t know the material, it won’t be enough. That said, just knowing the material isn’t enough either because doing well is also about managing your own psychology. The main mental obstacle is the discomfort of not knowing.\n\nSet yourself up for the least amount of discomfort. Book an anonymous, mock system design interview with engineers from top companies. Keep your skills sharp.\n\nUnlike engineering problems, design problems are more about not knowing. There are no optimal solutions. Progress is not quantifiable. There are no predetermined outcomes. It’s not enough to sum them up as ambiguous; they test your ability to thrive in ambiguity. Luckily, this can be learned through practice. It is a way to think, communicate, and solve problems. So, the skills you learn are transferable, even from practices that seem unrelated.\n\nThey are: the \"not knowing\" game, improv class, and zen koans. Try one for 10 days. If your system design interview skills don’t improve, I’ll buy you a Coke. Share your experience, tell us what we should write about next, and add anything else in the Typeform at the end of this post.\n\nThe way to play is to notice who knows stuff you don’t and then follow that thread. It’s easier with a topic you’re currently passionate about. For me, that’s art. I bring it up and listen for it everywhere. If someone mentions something I didn’t know, that’s a point. If they explain something I didn’t know, that’s double points. And if someone scores enough points: treat them like an old friend and see where it goes.\n\nThe other day, a stranger and I began talking at a café. A half hour later, we were in their house looking at their original copy of Dante’s Divine Trilogy which is about hell, purgatory, and heaven. It is hundreds of years old and surprisingly massive. Before this experience which was steeped in \"not knowing\"–an impromptu visit to a stranger’s house–I hadn’t even heard o",
      "content_type": "blog",
      "source_url": "https://interviewing.io/blog/never-written-code-but-passed-google-system-design",
      "author": "Kevin",
      "user_id": ""
    },
    {
      "title": "Overview of Beyond Cracking the Coding Interview",
      "content": "# Beyond Cracking the Coding Interview\n\n## Introduction\nThis section provides an overview of the book 'Beyond Cracking the Coding Interview', which aims to help candidates pass tough coding interviews, get noticed, and negotiate successfully.\n\n## Authors\n- Gayle L. McDowell\n- Mike Mroczka\n- Aline Lerner\n- Nil Mamano\n\n## Key Sections\n1. **Interview Checklist**: A guide to prepare for coding interviews.\n2. **Study Plan**: Strategies to enhance coding skills.\n3. **Programming Questions and Solutions**: A collection of 189 programming questions with solutions.\n4. **Career Guidance**: Insights on becoming a great product manager and landing jobs at top tech companies.\n\n## What's Inside\nThe book is structured into several parts:\n- **I. Ugly Truths & Hidden Realities**: Discusses the challenges of job searches and technical interviews.\n- **II. Job Searches, Start to Finish**: Covers resume writing and interview mechanics.\n- **III. Offers & Negotiation**: Details on job offers and negotiation strategies.\n- **IV. Behavioral Interviews**: Insights on behavioral interview techniques.\n- **V. Principles of Coding Interviews**: Technical aspects of coding interviews, including practice and evaluation.\n- **VI. Catalog of Technical Topics**: A catalog of important technical topics relevant to coding interviews.\n\n## Conclusion\nThis book serves as a comprehensive guide for candidates looking to improve their interview skills and navigate the job market effectively.",
      "content_type": "book",
      "source_url": "",
      "author": "Gayle L. McDowell, Mike Mroczka, Aline Lerner, Nil Mamano",
      "user_id": ""
    },
    {
      "title": "Why Job Searches Suck",
      "content": "Job searches suck— especially for engineers, who are, by and large, rational, well-intentioned people who expect the world to function according to some set of predictable rules. Why do job searches suck so much?\n\n- **Job searches are not deterministic**, and neither are interview outcomes. In job searches, effort doesn’t always correlate with results. For technical interviews specifically, there’s little predictability in how the same person will perform from interview to interview.\n- **No feedback loop**. When you apply online and don't get a response, you can't tell if you weren’t a fit or if no one even saw your application. Your insecurities can convince you that not only did a human look, but they quickly sized you up, saw right through you, and lasered in on every single flaw to conclude (correctly, in your mind) that you’re unfit for the job. When you interview, whether you pass or get rejected, you often don’t know why, which makes it difficult to know how to prepare the next time.\n- **The content of your resume** is often eclipsed by the brands in it. If you don’t have brand-name companies or schools, it’s much harder to get noticed. Recruiters are notoriously bad at making value judgments based on resumes. Despite these shortcomings, resumes are still the gold standard, and that means candidates from non-traditional backgrounds enter the game with a significant disadvantage.\n- **To get in the door**, you very likely have to know someone. Surprisingly, this is even true for candidates who look good on paper; recruiters often ignore online applications because the signal-to-noise ratio is so poor. But it’s especially true if you don’t look good on paper.\n- **Technical interviews are notoriously flawed** and not representative of the actual engineering work you do every day. This one is especially rough, and it bears out in our data. Senior engineers often do worse than juniors in their first few interviews because junior engineers have more recently completed an algorithms class or have done extensive interview prep. Senior engineers have been in the trenches, often focusing on building applications; there are very few engineering roles where you’re doing the types of academic problems that you get in interviews day in and day out.\n\nThese are just a few of the challenges, but the strategies in this book will help you navigate them and achieve success—however you define it. Given all these flaws, you might ask: How did we get here, where our technical interviews feel so divorced from the work and so unpredictable in their outcomes? For that, let’s take a brief look at the history of technical interviewing.",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    },
    {
      "title": "Section 3 Overview",
      "content": "This section contains the initial content of the book, which is currently not detailed. Further elaboration on key concepts and technical content is expected in subsequent sections.",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    },
    {
      "title": "Section 4 Overview",
      "content": "This section contains the initial part of the content, represented by the letter 'I'. Further details and explanations are required to provide a comprehensive understanding of the concepts covered in this section.",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    },
    {
      "title": "A Brief History of Technical Interviews",
      "content": "Technical interviewing has its roots as far back as the 1950s, at Shockley Semiconductor Laboratories in Mountain View, California. William Shockley’s interviewing methodology came out of the need to keep up with the innovative, rapidly moving, Cold War-fueled tech sector, something that traditional hiring approaches taken from established, skills-based assembly line industries simply couldn’t handle.\n\nShockley relied on questions that could gauge analytical ability, intellect, and potential quickly. One canonical question in this category has to do with coins:\n\n> You have eight identical-looking coins, except one is lighter than the rest. Figure out which one it is with just two weighings on a pan balance.\n\nThe techniques that Shockley developed were adopted by Microsoft during the 1990s, as the success of the desktop computer, and later, the first dot-com boom spurred an explosion in tech hiring. Like Shockley, Microsoft also needed to quickly and scalably assess high volumes of candidates for potential. As software engineering became increasingly complex, it was no longer possible to have a few centralized expert programmers manage the design and then delegate away the minutiae. Even rank-and-file developers needed to be able to produce under a variety of rapidly evolving conditions, where just mastery of specific skills wasn’t enough.\n\nThe puzzle format, in particular, was easy to standardize because individual hiring managers didn’t have to come up with their own interview questions, and a company could quickly build up its own interchangeable question repository. Over time, most companies did away with puzzle questions for engineers, and moved to algorithmic questions: these questions seemed more relevant but still assessed problem-solving skills.\n\nAt many top companies, such as Google, this need for interchangeable parts ultimately carried over to the interview process as well—rather than having individual teams run their own processes and pipelines, companies standardized it. This way, in addition to questions, you could effectively plug and play the interviewers themselves—any interviewer within your org could be quickly trained up and assigned to speak with any candidate, independent of the prospective team.\n\nHowever, companies didn’t always create incentives for engineers to work hard at being good interviewers, and as you’ll see later in this book, we believe that much of the flak that algorithmic interviews get is due to the interviewers conducting them (and, often, lack of training or proper incentives).\n\nSo where does this leave us? Technical interviews are, at best, a proxy for the day-to-day tasks that a software engineer actually does, and not all interviewers are good. But, regardless, do technical interviews work? Well, that's complicated and depends a lot on your definition of \"work.\" For whom, the candidate or the company? For what type of company? Compared to what?\n\nWe would argue that interviewing as a whole is flawed, and it's really a matter of picking your poison. However, even the most ardent defenders of these sorts of technical interviews agree that false negatives—great engineers who get rejected—are common. FAANGs and other companies who adopt these processes tolerate a high false negative rate, under the rationale that it's better to reject a good candidate than to hire a bad one. The process is optimized to reduce false positives.\n\nFor you, the candidate, that kind of sucks. But it is what it is, and that's what this book is here for: to help you avoid being one of those false negatives.",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    },
    {
      "title": "Introduction to Beyond Cracking the Coding Interview",
      "content": "# Beyond Cracking the Coding Interview\n\nThis book aims to help candidates pass tough coding interviews, get noticed, and negotiate successfully. It includes a comprehensive study plan, interview checklist, and various resources for preparing for technical interviews.\n\n## Key Sections\n- **Interview Checklist**: A guide to prepare for coding interviews.\n- **Study Plan**: A structured approach to studying for interviews.\n- **Programming Questions**: 189 programming questions and solutions to practice.\n- **Career Guidance**: Insights on becoming a great product manager and landing jobs at top tech companies like Google, Microsoft, and Apple.\n\n## Authors\n- Gayle L. McDowell\n- Mike Mroczka\n- Aline Lerner\n- Nil Mamano\n\n## Publication Information\n- Published by CareerCup, LLC, Palo Alto, CA.\n- Copyright © 2025 by CareerCup. All rights reserved.\n\n## ISBN\n- 978-1955706001 (ISBN 13)\n\n## Acknowledgments\n- Personal dedications from the authors to their families and readers.",
      "content_type": "book",
      "source_url": "",
      "author": "Gayle L. McDowell, Mike Mroczka, Aline Lerner, Nil Mamano",
      "user_id": ""
    },
    {
      "title": "Principles and Catalog of Coding Interviews",
      "content": "This section discusses the importance of effective problem-solving strategies and how to navigate coding interviews. It outlines a study plan, evaluation rubric, interview checklist, and Big-O analysis. Additionally, it categorizes data structures and algorithms into tiers based on their importance for interviews.\n\n### Key Components:\n- **Study Plan**: A detailed guide for practicing with the book's materials.\n- **Universal Rubric**: Insights into how interviewers evaluate candidates.\n- **Interview Checklist**: A breakdown of steps to take during a coding interview.\n- **Big-O Analysis**: Comprehensive coverage of the Big-O notation, crucial for technical interviews.\n- **Problem-Solving Strategies**: Techniques such as boundary thinking and trigger thinking.\n\n### Catalog of Topics:\n- **Tier 1**: Essential topics (sets, maps, trees, graphs).\n- **Tier 2**: Intermediate topics (heaps, sliding windows, prefix sums).\n- **Tier 3**: Niche topics available online (bctci.co/bonus).",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    },
    {
      "title": "How to Practice: Topics, Recipes, and Reusable Ideas",
      "content": "## Topics, Recipes, and Reusable Ideas\n\nThere are three related concepts you'll find as you peruse the Catalog: topics, reusable ideas, and recipes. Here's a quick definition to keep them straight:\n\n- **Topic**: A chapter from the Catalog, like Binary Search.\n- **Reusable Idea**: A coding idea that can typically be used across problems (and even across topics). They are tactical tips worth remembering, such as \"pass indices, not strings in recursive code to avoid using extra space.\" You'll typically find them next to the first problem where they are used (look for the 📌 icon).\n- **Coding Recipe**: A pseudo-code template related to a specific topic that can be used as a building block to solve similar problems with small tweaks.\n\nQuestions, comments, or bugs? Report bugs at [bctci.co/bugs](http://bctci.co/bugs) or geek out with the authors on Discord: [bctci.co/discord](http://bctci.co/discord).\n\nOur mantra? If you encounter something once, it’s a trick; if you encounter it repeatedly, it’s a tool.",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    },
    {
      "title": "Sliding Windows & Binary Search",
      "content": "AI interviewer, replays, and more materials for this chapter at [bctci co/binary-searchI](http://bctci.co/binary-searchI)",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    },
    {
      "title": "Sliding Windows & Binary Search",
      "content": "## Sliding Windows\nThe sliding window technique is a useful method for solving problems that involve arrays or lists. It allows you to maintain a subset of elements in a contiguous block and slide the window across the data structure to find solutions efficiently.\n\n### Key Concepts of Sliding Windows:\n- **Fixed-size window**: A window of a specific size that moves across the data.\n- **Dynamic-size window**: A window that can grow or shrink based on certain conditions.\n\n## Binary Search\nBinary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing the search interval in half.\n\n### Key Concepts of Binary Search:\n- **Divide and Conquer**: The algorithm divides the problem into smaller subproblems.\n- **Logarithmic Time Complexity**: The time complexity of binary search is O(log n).\n\n### Code Example for Binary Search:\n```python\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```\n\n### Applications:\n- Finding elements in a sorted array.\n- Solving problems related to searching and optimization.\n\nBy understanding and applying these techniques, you can solve a variety of algorithmic problems more efficiently.",
      "content_type": "book",
      "source_url": "",
      "author": "Unknown",
      "user_id": ""
    }
  ]
}